package bit;

public class BitBaseOpration {
    public static void main(String[] args) {
        example2more();
//        example3App();
    }

    /**
     * 二进制，byte，int 关系
     * <p>
     * 一。二进制运算符的操作范围
     * 进制运算符的作用范围与参与运算的变量的数据类型有关
     * 对于byte类型变量，由于byte以8-bit（8个二进制位）表示，因此相应的位运算符的作用范围就是8-bit；
     * .对于int类型变量，由于int以32-bit表示，因此位运算符的作用范围就是32-bit；
     * .假如两个大小不一的数据类型进行操作，那位运算的作用范围会以较大的数据类型作为基准范围。
     * <p>
     * byte=2~8次方=8 bit=2*16进制
     * 一hex=16进制=2*2*2*2=4bit
     * <p>
     * 二：符号
     * 高位，指在数据类型限定范围内靠左的二进制位；
     * 低位，指在数据类型限定范围内靠右的二进制位；
     * 符号位，指在数据类型限定范围内最左边的一个二进制位，符号位为0表示正数，1表示负数。
     * <p>
     * 补位：当原byte整数为正数时，提升为int类型时，补位全部以0补位；
     * 当原byte整数为负数时，提升为int类型时，补位全部以1补位；
     */
    private static void example1() {
        // byte类型的值范围是[-128,127]
        byte a = (byte) -55; //由于值在byte范围内，因此强制转换缩小变量内存范围不会改变原值
        byte b = (byte) 100;

        //输出（二进制数）-55：11111111111111111111111111001001
        System.out.println(Integer.toBinaryString(a));
        //输出：-55（重新提升范围，值不变）
        System.out.println(Integer.valueOf(a));
        //输出（二进制数）100：000000000000000000000000 1100100（高位的0会被省略显示）
        System.out.println(Integer.toBinaryString(b));
        System.out.println(Integer.valueOf(b)); //输出：100

        /**
         * 上面来自网络，下边再写个更简单的例子
         */
        System.out.println("me test");
        //11，正数直接按次方算就对，和10进制一样
        /**
         * 原码  0 0000000 00000000 00000000 00000011
         * 反码  0 0000000 00000000 00000000 00000011（正数的反码就是原码）
         * 补码  0 0000000 00000000 00000000 00000011（正数的补码就是原码）
         */
        System.out.println(Integer.toBinaryString(3));
        //11111111111111111111111111111101，负数从高位起，一不算
        /**
         * 原码  1 0000000 00000000 00000000 00000011
         * 反码  1 1111111 11111111 11111111 11111100（符号位不变 其它位都取反。）
         * 补码  1 1111111 11111111 11111111 11111101（反码的基础上+1）
         */
        System.out.println(Integer.toBinaryString(-3));


        /**
         * 计算机使用补码参与计算
         * 5 - 3 = 5 + ( -3 )
         * 相当于 00000000 00000000 00000000 00000101 +
         *       11111111 11111111 11111111 11111101
         *   = 1 00000000 00000000 00000000 00000010
         * 最高位产生了溢出，进位 1 被丢弃。结果就变成了 0010 也就是 2，5 - 3 = 2 没有毛病。
         */
    }


    private static void example2() {
        /**
         * 规则 与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值都是 1，则结果值相应的 bit 就是 1，否则为 0.
         * 3 & 5 = 1
         *   00000000 00000000 00000000 00000011
         * & 00000000 00000000 00000000 00000101
         * = 00000000 00000000 00000000 00000001
         */
        System.out.println(3 & 5);

        /**
         * 规则 与运算时，进行运算的两个数，从最低位到最高位，一一对应。如果某 bit 的两个数值对应的值只要 1 个为 1，则结果值相应的 bit 就是 1，否则为 0。
         * 3 | 5 = 1
         *   00000000 00000000 00000000 00000011
         * | 00000000 00000000 00000000 00000101
         * = 00000000 00000000 00000000 00000111
         */
        System.out.println(3 | 5);

        /**
         * 规则 对操作数的每一位进行操作，1 变成 0，0 变成 1。
         * ~5 = -6
         * ~ 00000000 00000000 00000000 00000101
         * = 11111111 11111111 11111111 11111010
         * 反11111111 11111111 11111111 11111001
         * 原10000000 00000000 00000000 00000110
         * =-6
         */
        System.out.println(~5);
    }

    /**
     * 2太多了，分两次说
     */
    private static void example2more() {
        /**
         * 规则 两个操作数进行异或时，对于同一位上，如果数值相同则为 0，数值不同则为 1。
         * 3 ^ 5 = 6
         *   00000000 00000000 00000000 00000011
         * & 00000000 00000000 00000000 00000101
         * = 00000000 00000000 00000000 00000110
         */
        System.out.println(3 ^ 5);
        /**
         * 值得注意的是 3 ^ 5 = 6,而 6 ^ 5 = 3
         * 异或运算可以作为简单的加解密运算算法。
         */


        /**
         * 规则 a >> b 将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向右方向移动 b 位，符号位不变，高位空出来的位补数值 0。
         * 5 >> 1=2
         *   00000000 00000000 00000000 00000101
         * = 000000000 00000000 00000000 0000010
         */
        System.out.println(5 >> 1);
        /**
         * 大家发现什么规律没有？a >> b = a / ( 2 ^ b ) ,所以 5 >> 1= 5 / 2 = 2,11 >> 2 = 11 / 4 = 2。
         */


        /**
         * 规则 a << b 将数值 a 的二进制数值从 0 位算起到第 b - 1 位，整体向左方向移动 b 位，符号位不变，低位空出来的位补数值 0。
         * 5 << 1 10
         *   00000000 00000000 00000000 00000101
         * = 0000000 00000000 00000000 000001010
         */
        System.out.println(5 << 1);
        /**
         * 综合上面两个可以看到，如果某个数值右移 n 位，就相当于拿这个数值去除以 2 的 n 次幂。如果某个数值左移 n 位，就相当于这个数值乘以 2 ^ n。
         */


//        >>>    :     无符号右移，忽略符号位，空位都以0补齐


        /**
         * copyof :可能是最通俗易懂的 Java 位操作运算讲解
         * https://blog.csdn.net/briblue/article/details/70296326
         * https://blog.csdn.net/briblue,作者的文章值得一看
         */
    }

    /**
     * -127
     *  10000001
     * &11111111
     * =10000001
     * 转int,高的24位补一
     *  11111111 11111111 11111111 10000001
     * &00000000 00000000 00000000 11111111
     * =00000000 00000000 00000000 10000001=129
     *
     * 但是我们有时候要的不是十进制相等，而是只需要补码相等，
     * 可以看到这个时候byte转换为int的时候 其高位 已经被补位1了，
     * 这个时候我们&0XFF 其本质原因就是想保持二进制补码的一致性。
     */
    private static void example3App() {
        byte[] a = new byte[10];
        a[0]= -127;
        System.out.println(Integer.toBinaryString(a[0]));
        System.out.println(a[0]);
        int c = a[0]&0xff;
        System.out.println(c);

    }

}
